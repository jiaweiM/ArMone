/*
 * *****************************************************************************
 * File: ScanFileUtil.java * * * Created on 08-03-2008
 *
 * Copyright (c) 2008 Xinning Jiang (vext@163.com)
 *
 * All right reserved. Use is subject to license terms.
 *
 * ******************************************************************************
 */
package cn.ac.dicp.gp1809.proteome.proteometools.fileOperation;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;

import cn.ac.dicp.gp1809.proteome.util.SequestScanName;
import cn.ac.dicp.gp1809.util.ioUtil.ExtensionFilenameFilter;

/**
 * This class is mainly for the easy accession of scan files (.dta or .out) by the scan number and the charge state of
 * the precursor ion. First, all the scan files are parsed into a map with the key of scannumber+charge, and then the
 * file name of the scan file can be generated by its scan number and the charge state.
 *
 * @author Xinning
 * @version 0.3, 06-05-2009, 14:22:25
 */
public class ScanFileUtil
{

    public static final String OUT_FILE = "out";
    public static final String DTA_FILE = "dta";

    public File parent;
    private String[] filenames;

    private Integer[] scannumberlist;
    private Map<String, SequestScanName> map = new HashMap<String, SequestScanName>();

    private Map<Integer, LinkedList<SequestScanName>> scanmap = new HashMap<Integer, LinkedList<SequestScanName>>();

    /**
     * The base name of the scan file. For example: for the scan file 20061026_QDN_SAX_SPE_F5.2227.2227.2.out, the base
     * name is 20061026_QDN_SAX_SPE_F5. This basename is commonly from the raw file while collecting the mass spectra.
     */
    private String basename;

    private String filttype = null;

    /**
     * @param folder the name of directory which contains the search files
     * @param extend extend of the file
     * @throws NullPointerException if the directory contains no sequest file
     */
    public ScanFileUtil(String foldername, String extend)
            throws NullPointerException
    {
        this(new File(foldername), extend);
    }

    /**
     * @param folder
     * @param extend extend of the file
     * @throws NullPointerException if the directory contains no sequest file
     */
    public ScanFileUtil(File folder, String extend) throws NullPointerException
    {
        this.parent = folder;

        if (extend.equals(DTA_FILE) || extend.equals(OUT_FILE))
            ;
        else {
            System.out.println("Only dta or out files can be pased!");
            throw new RuntimeException();
        }

        this.filttype = extend;
        System.out.println("listing files in " + parent.getName() + " ...");
        this.filenames = parent.list(new ExtensionFilenameFilter(extend));

        if (this.filenames == null)
            throw new NullPointerException("The path specified: "
                    + folder.getPath() + " doesn't exist or is not a dir.");

        if (this.filenames.length == 0)
            throw new NullPointerException("The folder: " + folder.getName()
                    + " contains none SEQUEST file!");

        this.getScanFileListMap();
    }

    /**
     * dta of out name
     *
     * @return
     */
    public String fileType()
    {
        return this.filttype;
    }

    /**
     * The base name of the scan file. For example: for the scan file 20061026_QDN_SAX_SPE_F5.2227.2227.2.out, the base
     * name is 20061026_QDN_SAX_SPE_F5. This basename is commonly from the raw file while collecting the mass spectra.
     *
     * @return the base name
     */
    public String getBaseName()
    {
        return this.basename;
    }

    /*
     * @param: String = scannumber+charge eg: scannumber = 1203,charge = 2
     * String = 12032
     */
    private void getScanFileListMap()
    {
        Set<Integer> set = new HashSet<Integer>();

        int len = this.filenames.length;
        if (len == 0) {
            System.out.println("No file in current directory.");
            return;
        }

        String name = this.filenames[0];
        int count = 0;

        for (int i = name.length() - 1; i >= 0; i--) {
            if (name.charAt(i) == '.') {
                count++;

                if (count == 4) {
                    this.basename = name.substring(0, i);
                    break;
                }

                /*
                 * switch (count) { case 4: this.basename = name.substring(0,
                 * i); i=0; break;// End, skip the first blank default: break; }
                 */

                /*
                 * switch (count) { case 3: break;// Scan end case 4: //
                 * scanNumberBeg = //
                 * Integer.parseInt(name.substring(i+1,preindex)); this.basename
                 * = name.substring(0, i); i = 0; break;// End case 1: break;//
                 * dta extension case 2: break;// charge states default: break;
                 * }
                 */
            }
        }

        for (int i = 0; i < len; i++) {
            name = filenames[i];
            SequestScanName scanname = new SequestScanName(name);
            int scan1 = scanname.getScanNumBeg();
            int scan2 = scanname.getScanNumEnd();
            short charge = scanname.getCharge();

            if (scan1 == scan2) {
                set.add(scan1);
                String index = scan1 + "" + charge;
                map.put(index, scanname);

                this.addToMap(scan1, scanname, scanmap);
            } else {
                set.add(scan1);
                set.add(scan2);

                String index = scan1 + "" + charge;
                map.put(index, scanname);
                index = scan2 + "" + charge;
                map.put(index, scanname);

                this.addToMap(scan1, scanname, scanmap);
                this.addToMap(scan2, scanname, scanmap);
            }
        }

        this.scannumberlist = set.toArray(new Integer[set.size()]);
    }

    /**
     * Add to map
     *
     * @param scan
     * @param name
     * @param scanmap
     */
    private void addToMap(int scan, SequestScanName name,
            Map<Integer, LinkedList<SequestScanName>> scanmap)
    {
        LinkedList<SequestScanName> list;
        Integer it = scan;
        if ((list = scanmap.get(it)) == null) {
            list = new LinkedList<SequestScanName>();
            scanmap.put(it, list);
        }

        list.add(name);

    }

    /**
     * Map consisted as : key scannumber+charge, value filenames
     *
     * @return
     */
    public Map<String, SequestScanName> getScanFileMap()
    {
        return this.map;
    }

    /**
     * Get the outfilename through scannumber+charge. For example, scannumber = 1203,charge = 2 the scan charge String =
     * 12032
     *
     * @param scancharge :scannumber+charge
     * @return filename the file name with NO path information (NOT the path)
     */
    public SequestScanName getScanFileName(String scancharge)
    {
        SequestScanName name = map.get(scancharge);

        return name;
    }

    /**
     * Get the scan filenames with the specific scan number (commonly these files are with different charge state by low
     * mass accuracy mass spectrometer)
     *
     * @param scannum
     * @return
     */
    public LinkedList<SequestScanName> getScanFilenames(int scannum)
    {
        return this.scanmap.get(scannum);
    }

    /**
     * Get the file name for the scan with specific charge state
     *
     * @param scan
     * @param charge
     * @return filename the file name with NO path information
     */
    public SequestScanName getScanFileName(int scan, short charge)
    {

        String scancharge = new StringBuilder().append(scan).append(charge)
                .toString();

        SequestScanName name = map.get(scancharge);

        return name;
    }

    /**
     * @return the filename list in the current folder;
     */
    public SequestScanName[] getScanFileNameList()
    {
        return this.map.values().toArray(new SequestScanName[this.map.size()]);
    }

    /**
     * Get the filename list for the specific scancharge array. The returned list of name is unsorted and will directly
     * related to the given scancharge array. That is, for a given scancharge String at the index of i in scancharge
     * array, its file name will also locate at the index of i in the returned file name array.
     *
     * @param scancharge
     * @return
     */
    public String[] getFileName(String[] scancharge)
    {

        ArrayList<SequestScanName> namelist = new ArrayList<SequestScanName>();

        for (int i = 0; i < scancharge.length; i++) {
            SequestScanName name = this.map.get(scancharge[i]);

            if (name != null)
                namelist.add(name);
        }

        return namelist.toArray(new String[0]);
    }

    /**
     * filename with no duplicated;(merged by HashSet, order reseted) the duplicated ones come from the scan with more
     * than one origin spectrum
     *
     * @param scancharge
     * @return filename with no duplicated;
     */
    public SequestScanName[] getUnduplicatedFileName(String[] scancharge)
    {
        HashMap<String, SequestScanName> nameset = new HashMap<String, SequestScanName>();

        for (int i = 0; i < scancharge.length; i++) {
            SequestScanName name = this.map.get(scancharge[i]);

            if (name != null)
                nameset.put(name.getScanName(), name);
        }

        return nameset.values().toArray(new SequestScanName[nameset.size()]);
    }

    /**
     * The directory for parsing.
     *
     * @return
     */
    public File getDirectory()
    {
        return this.parent;
    }

    /**
     * @return scan number list(pure digest)
     */
    public Integer[] getScanNumList()
    {
        return this.scannumberlist;
    }
}
